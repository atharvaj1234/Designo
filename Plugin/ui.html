<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Fonts and Title -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=Jura:wght@300..700&family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
    rel="stylesheet">
  <title>Designo</title>
  <!-- Add your CSS styles here or link external stylesheet -->
  <style>
    /* Basic Styles - Add your full CSS here */
    body {
      font-family: 'Inter', sans-serif;
      margin: 0;
      padding: 10px;
      background-color: #f4f4f4;
      color: #333;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      max-height: 580px;
      /* Adjust as needed */
    }

    /* Added max-height */
    .header-with-icon {
      display: flex;
      align-items: center;
      gap: 10px;
      padding-bottom: 10px;
      border-bottom: 1px solid #eee;
    }

    .circle-icon img {
      border-radius: 50%;
    }

    #auth-area {
      padding: 10px 0;
      text-align: center;
    }

    #auth-area button {
      padding: 8px 15px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      background-color: #4285F4;
      color: white;
    }

    #auth-area button:hover {
      background-color: #357ae8;
    }

    #auth-area span {
      margin-right: 10px;
    }

    #chat-history {
      flex-grow: 1;
      overflow-y: auto;
      padding: 10px;
      border: 1px solid #ccc;
      margin-bottom: 10px;
      background-color: white;
      border-radius: 4px;
    }

    .message {
      margin-bottom: 8px;
      padding: 8px 12px;
      border-radius: 15px;
      max-width: 85%;
      word-wrap: break-word;
    }

    .message.user {
      background-color: #d1e7fd;
      align-self: flex-end;
      border-bottom-right-radius: 0;
      margin-left: auto;
    }

    .message.ai {
      background-color: #e2e3e5;
      align-self: flex-start;
      border-bottom-left-radius: 0;
      margin-right: auto;
    }

    .message.status,
    .message.error,
    .message.success {
      font-style: italic;
      color: #666;
      text-align: center;
      background-color: transparent;
      max-width: 100%;
    }

    .message.error {
      color: red;
      font-weight: bold;
    }

    .message.success {
      color: green;
    }

    .input-area {
      display: flex;
      gap: 5px;
      border-top: 1px solid #eee;
      padding-top: 10px;
    }

    #prompt {
      flex-grow: 1;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      resize: none;
      min-height: 40px;
      max-height: 100px;
    }

    /* Added max-height */
    #send {
      padding: 0 15px;
      cursor: pointer;
      background-color: #1a73e8;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 1.5em;
    }

    #send:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }

    .loader {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #3498db;
      border-radius: 50%;
      width: 15px;
      height: 15px;
      animation: spin 1s linear infinite;
      display: inline-block;
      margin-left: 5px;
      vertical-align: middle;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <!-- Header -->
    <div class="header-with-icon">
      <div class="circle-icon">
        <img id="header-icon" src="data:image/png;base64,<base 64 here>" width="40" height="40" alt="Designo Icon">
      </div>
      <h2 style="font-size:large; font-family: jura; font-weight:700;">Designo</h2>
    </div>

    <!-- Authentication Area -->
    <!-- *** MODIFIED Authentication Area *** -->
    <div id="auth-area">
      <span id="user-info" style="display: none;">Logged in as: <span id="user-name-display"></span></span>
      <!-- Token Input Area (Initially hidden) -->
      <div id="token-input-area" style="display: none; margin-top: 10px;">
          <label for="authTokenInput">Paste Token:</label>
          <input type="text" id="authTokenInput" size="30" style="margin-left: 5px; padding: 4px;" placeholder="Paste token from browser here...">
          <button id="verifyTokenButton" style="margin-left: 5px;">Verify Token</button>
          <p id="token-status" style="font-size: 0.9em; color: grey; margin-top: 5px;"></p>
      </div>
      <button id="auth-button" style="margin-top: 10px;">Sign in with Google</button> <!-- Login button always visible -->
    </div>

    <!-- Chat History -->
    <div id="chat-history">
      <div class="message status" id="initial-message">
        Please sign in to use the AI assistant.
      </div>
    </div>

    <!-- Input Area -->
    <div class="input-area">
      <textarea id="prompt" placeholder="Please sign in..." disabled></textarea>
      <button id="send" disabled>➤</button> <!-- Send Arrow Icon -->
    </div>
  </div>

  <!-- Marked library for Markdown -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script type="module">
    // --- Config ---
    // Make sure this URL matches where your Python backend is running
    const BACKEND_BASE_URL = 'https://nr8fxs4v-8080.inc1.devtunnels.ms'; // Base URL of your Flask app

    // --- UI Elements ---
    const chatHistory = document.getElementById("chat-history");
    const promptInput = document.getElementById("prompt");
    const sendButton = document.getElementById("send");
    const initialMessage = document.getElementById("initial-message");
    const authArea = document.getElementById("auth-area");
    const authButton = document.getElementById("auth-button");
    const userInfoSpan = document.getElementById("user-info");
    const userNameDisplay = document.getElementById("user-name-display")
    const tokenInputArea = document.getElementById("token-input-area");
    const authTokenInput = document.getElementById("authTokenInput");
    const verifyTokenButton = document.getElementById("verifyTokenButton");
    const tokenStatus = document.getElementById("token-status");

    // --- State ---
    let currentMode = null; // 'create', 'modify', 'answer' - Determined by Figma selection
    let currentFrameId = null;
    let currentFrameName = null;
    let selectedElementInfo = null;
    let isLoading = false;
    let isLoggedIn = false;
    let currentProcessingMessageDiv = null; // Message div showing loading status
    let pendingRequestData = null; // Store data between Figma message and backend response

    let authPollInterval = null; // Variable to hold the interval timer ID
    const POLLING_INTERVAL_MS = 3000; // Check auth status every 3 seconds
    const POLLING_TIMEOUT_MS = 180000; // Stop polling after 3 minutes (adjust as needed)
    let pollingStartTime = null; // Track when polling started

    let userAuthToken = null; // <<< Store the verified custom token
    let userInfo = null; // Store user details

    const storedToken = null;
    const storedUserInfo = null;

    // --- ADDED: Polling Function Definitions ---

    function startAuthPolling() {
      stopAuthPolling(); // Clear any previous interval before starting a new one

      console.log("Starting authentication polling...");
      pollingStartTime = Date.now(); // Record start time for timeout

      // Initial check immediately
      checkAuthStatus();

      // Set up the interval
      authPollInterval = setInterval(async () => {
        // Only poll if the UI state still thinks we are not logged in
        if (!isLoggedIn) {
          // console.log("Polling auth status..."); // Keep this log minimal if it gets too noisy
          await checkAuthStatus(); // Use await to ensure check finishes before next interval logic (though setInterval doesn't wait)

          // Check for timeout inside the interval
          if (pollingStartTime && (Date.now() - pollingStartTime >= POLLING_TIMEOUT_MS)) {
            console.warn("Polling timed out after", POLLING_TIMEOUT_MS / 1000, "seconds.");
            stopAuthPolling(); // Stop on timeout
            // Only show timeout message if still not logged in
            if (!isLoggedIn) {
              addMessage("Login check timed out. If you completed the sign-in, please reload the plugin or try logging out and back in.", "error");
            }
          }
        } else {
          // If isLoggedIn became true (likely updated by checkAuthStatus), stop polling.
          console.log("User is logged in, stopping polling.");
          stopAuthPolling();
        }
      }, POLLING_INTERVAL_MS);
    }

    function stopAuthPolling() {
      if (authPollInterval) {
        clearInterval(authPollInterval); // Clear the interval timer
        authPollInterval = null;       // Reset the variable
        pollingStartTime = null;     // Reset start time
        console.log("Stopped authentication polling.");
      }
    }

    // --- END Polling Function Definitions ---


    // --- Helper Functions ---

    function addMessage(text, type = "status", isLoadingSpinner = false) {
      if (initialMessage && initialMessage.parentNode === chatHistory) {
        chatHistory.removeChild(initialMessage); // Remove initial message once interaction starts
      }
      const messageDiv = document.createElement("div");
      messageDiv.classList.add("message", type);

      // Sanitize and render Markdown only for AI responses for security
      if (type === "ai") {
        // Basic sanitization (consider a more robust library like DOMPurify in production)
        const sanitizedHtml = marked.parse(text).replace(/<script.*?>.*?<\/script>/gi, '');
        messageDiv.innerHTML = sanitizedHtml;
      } else {
        // For user, status, error: display as plain text
        messageDiv.textContent = text;
      }

      if (isLoadingSpinner) {
        const loader = document.createElement("div");
        loader.classList.add("loader");
        messageDiv.appendChild(loader);
        currentProcessingMessageDiv = messageDiv; // Track the message with the spinner
      }

      chatHistory.appendChild(messageDiv);
      // Scroll to bottom only if user is near the bottom
      const isScrolledToBottom = chatHistory.scrollHeight - chatHistory.clientHeight <= chatHistory.scrollTop + 1;
      if (isScrolledToBottom) {
        chatHistory.scrollTop = chatHistory.scrollHeight;
      }

      return messageDiv;
    }

    function removeSpinner() {
      if (currentProcessingMessageDiv) {
        const loader = currentProcessingMessageDiv.querySelector('.loader');
        if (loader) {
          loader.remove();
        }
        currentProcessingMessageDiv = null; // Clear the tracked message
      }
    }

    function setLoading(loading, statusText = null) {
        isLoading = loading;
        // Enable/disable based on login (token presence) AND mode
        promptInput.disabled = loading || !userAuthToken || !currentMode;
        sendButton.disabled = loading || !userAuthToken || !currentMode || !promptInput.value.trim();

        removeSpinner();
        if (loading && statusText) {
            addMessage(statusText, "status", true);
        } else if (!loading) {
            updatePromptPlaceholder();
        }
    }


    function updatePromptPlaceholder() {
      if (!userAuthToken) { // Check for token instead of isLoggedIn
            promptInput.placeholder = "Please sign in and verify token...";
      } else if (currentMode === "create") {
        promptInput.placeholder = currentFrameName ? `Describe design for "${currentFrameName}"...` : "Select empty frame...";
      } else if (currentMode === "modify") {
        promptInput.placeholder = selectedElementInfo ? `Describe change for "${selectedElementInfo.name}"...` : "Select element...";
      } else if (currentMode === "answer") {
        promptInput.placeholder = "Ask a design question or give an instruction...";
      } else {
        promptInput.placeholder = "Select a target in Figma or ask a question...";
      }
    }

    function updateLoginUI() {
        if (userAuthToken && userInfo) {
            isLoggedIn = true;
            userNameDisplay.textContent = userInfo.name || userInfo.email;
            userInfoSpan.style.display = 'inline';
            tokenInputArea.style.display = 'none'; // Hide token input once verified
            authTokenInput.value = ''; // Clear input
            tokenStatus.textContent = '';
            authButton.textContent = 'Logout';
            authButton.onclick = handleLogout; // Change button action
             // Enable input based on current selection state
             promptInput.disabled = isLoading || !currentMode;

            if (initialMessage && initialMessage.textContent.includes("sign in") || initialMessage.textContent.includes("verify")) {
                initialMessage.textContent = "Select an element in Figma or ask a question.";
            }
             // Request initial selection state NOW that we are fully authenticated
             console.log("Requesting initial selection state from code.js after token verification.");
             parent.postMessage({ pluginMessage: { type: 'request-initial-selection' }}, '*');

        } else {
            isLoggedIn = false;
            userAuthToken = null; // Ensure token is null if not logged in
            userInfo = null;
            userInfoSpan.style.display = 'none';
            tokenInputArea.style.display = 'none'; // Keep hidden initially
            authButton.textContent = 'Sign in with Google';
            authButton.onclick = handleLogin;
            promptInput.disabled = true; // Disable input
            if (initialMessage) {
                 initialMessage.textContent = "Please sign in to use the AI assistant.";
            }
        }
        // Update placeholders and button states regardless
        updatePromptPlaceholder();
        setLoading(isLoading); // Re-evaluate button states
    }


    // Uint8Array to Base64 (used for modify images)
    function uint8ArrayToBase64(bytes) {
      // This function seems correct, keeping it as is.
      return new Promise((resolve, reject) => {
        const blob = new Blob([bytes], { type: "image/png" });
        const reader = new FileReader();
        reader.onload = () => {
          const dataUrl = reader.result;
          const base64 = dataUrl.split(",")[1];
          if (!base64) {
            reject(new Error("Failed to extract Base64 string from Data URL."));
            return;
          }
          resolve(base64);
        };
        reader.onerror = (error) => reject(error);
        reader.readAsDataURL(blob);
      });
    }

    // Reset UI state related to Figma selection
    function resetFigmaSelectionState() {
      // console.log("Resetting Figma selection state.");
      // currentMode = null; // Keep 'answer' as default if nothing selected
      // currentFrameId = null;
      // currentFrameName = null;
      // selectedElementInfo = null;
      // pendingRequestData = null;
      // Don't clear promptInput.value here, user might be typing a general question
      // updatePromptPlaceholder();
      setLoading(isLoading); // Update button states based on current loading/login status
    }

    // --- Authentication ---

    // --- Inside index.html ---

    async function checkAuthStatus() {
      console.log("Checking authentication status...");
      // Add a flag to prevent multiple simultaneous checks if polling is fast
      if (window.checkingAuthStatus) return;
      window.checkingAuthStatus = true;

      try {
        const response = await fetch(`${BACKEND_BASE_URL}/api/auth/status`, {
          method: 'GET',
          credentials: 'include', // Crucial: sends cookies
          headers: {
            'Accept': 'application/json',
          }
        });

        if (!response.ok) {
          // Log non-OK responses but don't necessarily throw an error immediately
          // unless it's a 4xx/5xx status that indicates a real problem.
          console.warn(`Auth status check returned non-OK status: ${response.status}`);
          // Only throw if it's clearly an error preventing login check
          if (response.status >= 400) {
            throw new Error(`Auth status check failed: ${response.status}`);
          }
          // Otherwise, maybe just wait for the next poll cycle
          window.checkingAuthStatus = false;
          return; // Exit this check if status is non-OK but not a clear error (e.g., 304 Not Modified)
        }

        const data = await response.json();

        // --- *** THIS IS THE CRITICAL SECTION *** ---
        if (data.isLoggedIn && !isLoggedIn) { // Check !isLoggedIn to prevent redundant updates
          console.log("Polling detected successful login. Updating UI.", data.userInfo);
          isLoggedIn = true; // <<< SET THE STATE FIRST!
          stopAuthPolling(); // Stop polling immediately after detecting login

          // Update UI elements
          userInfoSpan.textContent = `Logged in as: ${data.userInfo.name || data.userInfo.email}`;
          userInfoSpan.style.display = 'inline';
          authButton.textContent = 'Logout';
          authButton.onclick = handleLogout;

          // Update initial message if needed
          if (initialMessage && initialMessage.textContent.includes("sign in")) {
            initialMessage.textContent = "Select an element in Figma or ask a question.";
          }

          // --- Explicitly update prompt state AFTER setting isLoggedIn ---
          updatePromptPlaceholder(); // Update placeholder text
          setLoading(false); // Ensure loading state is off and button states are re-evaluated
          // This will enable/disable based on the new isLoggedIn state


          // --- Request initial selection from Figma ---
          console.log("Requesting initial selection state from code.js");
          parent.postMessage({ pluginMessage: { type: 'request-initial-selection' } }, '*');


        } else if (!data.isLoggedIn && isLoggedIn) {
          // Handle case where session becomes invalid on backend
          console.warn("Polling detected user is no longer logged in on backend.");
          isLoggedIn = false;
          // Optionally call handleLogout() or just update UI directly
          userInfoSpan.style.display = 'none';
          authButton.textContent = 'Sign in with Google';
          authButton.onclick = handleLogin;
          promptInput.disabled = true;
          if (initialMessage) {
            initialMessage.textContent = "Your session expired. Please sign in again.";
          }
          updatePromptPlaceholder();
          setLoading(isLoading); // Update buttons
          stopAuthPolling(); // Stop polling if logged out

        } else {
          // Either still logged out, or already logged in - no state change needed
          // console.log(`Auth status check: No change (isLoggedIn=${isLoggedIn}, data.isLoggedIn=${data.isLoggedIn})`);
        }
      } catch (error) {
        console.error("Error checking auth status:", error);
        // Don't assume logged out on network error, just wait for next poll
        // isLoggedIn = false;
        // addMessage(`Error checking login status: ${error.message}`, "error");
        // promptInput.disabled = true;
        // updatePromptPlaceholder();
        // setLoading(isLoading);
      } finally {
        window.checkingAuthStatus = false; // Allow next check
      }
    }

    function handleLogin() {
      // 1. Tell code.js to open the external browser
      console.log("Requesting external login process start from code.js...");
      parent.postMessage({
           pluginMessage: {
                type: 'request-external-login',
                backendUrl: BACKEND_BASE_URL
           }
       }, '*');

      // 2. Show the token input area and instructions
      tokenInputArea.style.display = 'block';
      tokenStatus.textContent = 'Complete sign-in in the browser, then paste the token here.';
      authTokenInput.focus();
      // 3. NO POLLING NEEDED HERE ANYMORE
    }

    // --- NEW: Handle Token Verification ---
    verifyTokenButton.onclick = async () => {
        const token = authTokenInput.value.trim();
        if (!token) {
            tokenStatus.textContent = 'Please paste the token first.';
            return;
        }

        tokenStatus.textContent = 'Verifying token...';
        setLoading(true, "Verifying authentication...");

        try {
            const response = await fetch(`${BACKEND_BASE_URL}/api/auth/verify_token`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                },
                body: JSON.stringify({ token: token }),
            });

            const data = await response.json();

            if (response.ok && data.success) {
                console.log("Token verified successfully:", data);
                userAuthToken = data.authToken; // Store the verified token
                userInfo = data.userInfo;      // Store user info
                // ** Store token securely (e.g., Figma plugin storage API or localStorage if allowed/appropriate) **
                // localStorage.setItem('userAuthToken', userAuthToken); // Example using localStorage
                // localStorage.setItem('userInfo', JSON.stringify(userInfo));
                parent.postMessage({ pluginMessage: { type: 'set-token', token: {userAuthToken, userInfo} }}, '*');
                // figma.clientStorage.setAsync('userAuthToken', userAuthToken); // Example using Figma storage
                // figma.clientStorage.setAsync('userInfo', userInfo);

                tokenStatus.textContent = 'Verification successful!';
                addMessage("✅ Login successful!", "success");
                updateLoginUI(); // Update the rest of the UI

            } else {
                throw new Error(data.error || `Verification failed: ${response.status}`);
            }

        } catch (error) {
            console.error("Token verification failed:", error);
            tokenStatus.textContent = `Verification failed: ${error.message}`;
            userAuthToken = null; // Clear token on failure
            userInfo = null;
            updateLoginUI(); // Reset UI to logged-out state
        } finally {
            setLoading(false);
        }
    };
// --- Modified Logout ---
async function handleLogout() {
      console.log("Attempting logout...");
      if (!userAuthToken) return; // Can't logout if no token

      setLoading(true, "Logging out...");
      const tokenToInvalidate = userAuthToken; // Store locally before clearing state
      userAuthToken = null; // Clear state immediately
      userInfo = null;
      isLoggedIn = false;
      // Clear stored token
      // localStorage.removeItem('userAuthToken');
      // // localStorage.removeItem('userInfo');
      // await figma.clientStorage.deleteAsync('userAuthToken'); // Clear Figma storage
      // await figma.clientStorage.deleteAsync('userInfo');


      try {
           const response = await fetch(`${BACKEND_BASE_URL}/logout`, {
                method: 'POST',
                headers: {
                    // Send the token that needs invalidating
                    'Authorization': `Bearer ${tokenToInvalidate}`,
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                }
           });
           const data = await response.json();
           if (!response.ok || !data.success) {
                // Log error but UI is already logged out
                console.warn("Logout request to backend failed or reported error:", data.error || response.status);
           }
           console.log("Logout signal sent to backend.");

      } catch(error) {
          console.error("Error sending logout signal to backend:", error);
          // UI is already logged out, maybe show a different message
      } finally {
          // Update UI fully
          resetFigmaSelectionState();
          chatHistory.innerHTML = '';
          addMessage("You have been logged out.", "status");
          updateLoginUI(); // This will ensure UI is in logged-out state
          setLoading(false);
      }
    }


    // --- Call Backend API ---
    // --- Modified Backend Call ---
    async function callBackendApi(payload) {
        // Remove isLoggedIn check, rely on userAuthToken presence
        if (!userAuthToken) {
            addMessage("Authentication token missing. Please sign in and verify.", "error");
            // Maybe force logout UI state
            handleLogout(); // Or just updateLoginUI();
            return;
        }

        setLoading(true, "AI Assistant is thinking...");
        console.log("Sending to backend (/chat):", payload);

        try {
            const response = await fetch(`${BACKEND_BASE_URL}/chat`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${userAuthToken}`, // <<< SEND THE TOKEN
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                },
                body: JSON.stringify(payload),
            });

            if (!response.ok) {
                let errorMsg = `Backend request failed: ${response.status}`;
                let errorData = null;
                try { errorData = await response.json(); } catch (e) {}

                if (response.status === 401) { // Unauthorized (Token invalid or expired)
                     errorMsg = errorData?.error || "Your session expired or token is invalid. Please sign in again.";
                     addMessage(errorMsg, "error");
                     // Force logout in UI
                     await handleLogout(); // Use await if handleLogout becomes async (due to storage)
                } else if (errorData && errorData.error) {
                     errorMsg = `Backend Error: ${errorData.error}`;
                     throw new Error(errorMsg); // Throw other backend errors
                } else {
                    throw new Error(errorMsg); // Throw generic fetch error
                }
                return; // Stop processing if 401 happened
            }

            // ... (rest of success processing: result = await response.json(), postMessage to code.js, addMessage, etc.) ...
            // (This part remains the same as before)
            const result = await response.json();
            console.log("Received from backend:", result);
            removeSpinner(); // Remove spinner before adding AI response

            if (result.success) {
                if (result.mode === 'create' && result.svg) {
                    parent.postMessage({ pluginMessage: { type: 'finalize-creation', svgContent: result.svg, targetFrameId: pendingRequestData.targetFrameId }}, '*');
                } else if (result.mode === 'modify' && result.svg) {
                    parent.postMessage({ pluginMessage: { type: 'replace-element-with-svg', svgContent: result.svg, originalElementId: pendingRequestData.originalElementId }}, '*');
                } else if (result.mode === 'answer' && result.answer !== undefined) {
                    addMessage(result.answer, "ai");
                    resetFigmaSelectionState();
                    promptInput.value = '';
                    setLoading(false); // Unlock immediately after answer
                } else {
                    throw new Error("Received success, but backend response format was unexpected.");
                }
            } else {
                throw new Error(result.error || "Backend returned an unspecified error.");
            }

        } catch (error) {
            // ... (error handling: removeSpinner, addMessage, postMessage 'backend-error', resetFigmaSelectionState) ...
            // (This part remains the same, but ensure setLoading(false) is called)
             console.error("Error calling backend API:", error);
              removeSpinner(); // Ensure spinner is removed on error
              const displayError = error.message || "Could not connect to the backend.";
              addMessage(displayError, "error");
              if (pendingRequestData) {
                   parent.postMessage({ pluginMessage: { type: 'backend-error', error: displayError }}, '*');
              }
              resetFigmaSelectionState();
              setLoading(false); // Ensure UI unlocks on error
        } finally {
             // setLoading is handled within success/error paths now
             pendingRequestData = null;
        }
    }


    // --- Listen for Messages from Figma Code (code.js) ---
    window.onmessage = async (event) => {
      // Make sure the message is from the Figma plugin environment
      if (!event.data.pluginMessage) return;

        if (!event.data.pluginMessage) return;
        const message = event.data.pluginMessage;

        // Use token presence for guard
        if (!userAuthToken) {
             if (message.type !== 'backend-error' && message.type !== 'modification-error') {
                 console.log("Ignoring message from code.js because user token is not verified:", message.type);
                 return;
             }
        }
        // *** END GUARD *** ---

      switch (message.type) {
        // --- Figma Selection Updates ---
        case "selection-update":
        case "initial-selection-response": // Handle initial response similarly
          currentMode = message.mode; // 'create', 'modify', or 'answer'
          currentFrameId = message.frameId;
          currentFrameName = message.frameName;
          selectedElementInfo = message.element;

          resetFigmaSelectionState(); // Reset placeholders based on new state

          if (currentMode === "create") {
            addMessage(`Selected empty frame "${currentFrameName}". Ready to generate.`, "status");
          } else if (currentMode === "modify") {
            addMessage(`Selected element "${selectedElementInfo?.name || 'unnamed'}" (${selectedElementInfo?.type}) in frame "${currentFrameName}". Ready to modify.`, "status");
          } else { // 'answer' mode (nothing valid selected)
            addMessage("No specific element selected. Ask a general question or give an instruction.", "status");
          }
          // No need to call setLoading here, resetFigmaSelectionState updates button states
          break;

        case "selection-invalid": // Nothing usable selected
          currentMode = 'answer'; // Default to answer mode
          resetFigmaSelectionState();
          addMessage(message.reason || "Selection invalid or cleared. Ready for questions.", "status");
          // No need to call setLoading here
          break;

        // --- Frontend tells Backend to Proceed (Triggered by Send Button) ---
        // These messages come FROM code.js AFTER it has prepared necessary data (like images)
        case "proceed-to-backend-create":
          pendingRequestData = { targetFrameId: message.targetFrameId };
          const createPayload = {
            mode: 'create', // Explicitly set mode
            userPrompt: message.userPrompt,
            context: message.context, // { frameName }
          };
          callBackendApi(createPayload);
          break;

        case "proceed-to-backend-modify":
          setLoading(true, "Encoding image data..."); // Show encoding status
          try {
            const frameBase64Image = await uint8ArrayToBase64(message.framePngBytes);
            const elementBase64Image = await uint8ArrayToBase64(message.elementPngBytes);
            removeSpinner(); // Remove encoding message

            pendingRequestData = { originalElementId: message.originalElement.id };
            const modifyPayload = {
              mode: 'modify', // Explicitly set mode
              userPrompt: message.userPrompt,
              context: { // Restructure context slightly for backend
                frameName: message.context.frameName,
                element: message.originalElement // Send full element info
              },
              frameDataBase64: frameBase64Image,
              elementDataBase64: elementBase64Image,
            };
            callBackendApi(modifyPayload);

          } catch (conversionError) {
            console.error("Base64 Conversion Error:", conversionError);
            removeSpinner(); // Remove encoding message
            addMessage(`Error processing image: ${conversionError.message}`, "error");
            setLoading(false); // Unlock UI
            resetFigmaSelectionState();
          }
          break;

        // --- Final Success/Error Callbacks FROM code.js (after Figma interaction) ---
        case "creation-success":
          setLoading(false); // Unlock UI
          addMessage(`✅ Success! New design added to frame "${currentFrameName}".`, "success");
          promptInput.value = ""; // Clear prompt after success
          resetFigmaSelectionState();
          break;

        case "modification-success":
          setLoading(false); // Unlock UI
          addMessage(`✅ Success! Element updated in frame "${currentFrameName}".`, "success");
          promptInput.value = "";
          resetFigmaSelectionState();
          break;

        case "modification-error": // Error during Figma insertion/replacement
        case "backend-error": // Error reported by backend and forwarded by code.js
          setLoading(false); // Unlock UI
          addMessage(`❌ Error: ${message.error}`, "error");
          resetFigmaSelectionState(); // Also reset selection state
          break;

        // --- General Status Updates from Figma ---
        case "status-update":
          if (message.isLoading) {
            setLoading(true, message.text); // Show loading with text
          } else {
            // If it's just an informational status update without loading:
            addMessage(`ℹ️ ${message.text}`, "status");
            // Don't change the main loading state unless Figma explicitly stops it
          }
          break;
        
        case "token":
          storedToken = message.token.storedToken;
          storedUserInfo = message.token.storedUserInfo;
          break;

        default:
          console.warn("Unknown message type received from code.js:", message.type);
          break;
      }
    };

    // --- Input Handling & Sending ---
    promptInput.oninput = () => {
      // Update send button state based on input, login, selection, and loading status
      sendButton.disabled = isLoading || !isLoggedIn || !currentMode || !promptInput.value.trim();
    };

    promptInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey && !sendButton.disabled) {
        e.preventDefault(); // Prevent newline
        sendButton.click(); // Trigger send
      }
    });

    sendButton.onclick = () => {
      const userPrompt = promptInput.value.trim();

      if (!isLoggedIn) {
        addMessage("Please sign in first.", "error");
        return;
      }
      if (!currentMode) {
        addMessage("Please select an element in Figma or clear selection to ask a question.", "error");
        return;
      }
      if (!userPrompt) {
        addMessage("Please enter a description, instruction, or question.", "error");
        promptInput.focus();
        return;
      }

      addMessage(userPrompt, "user"); // Display user's prompt immediately

      // --- Decide action based on mode ---
      if (currentMode === 'create' || currentMode === 'modify') {
        // Ask code.js to prepare context (e.g., export images for modify)
        setLoading(true, "Preparing request for Figma...");
        parent.postMessage({
          pluginMessage: {
            type: "request-ai-context", // New type for code.js
            mode: currentMode,
            frameId: currentFrameId,
            userPrompt: userPrompt,
            elementInfo: selectedElementInfo, // Only relevant for modify
          },
        }, "*");
      } else if (currentMode === 'answer') {
        // Call backend directly for answer mode
        const answerPayload = {
          mode: 'answer',
          userPrompt: userPrompt,
          context: {} // No specific Figma context needed usually for general questions
        };
        callBackendApi(answerPayload);
        // Clear prompt immediately for answer mode after sending
        promptInput.value = "";
        sendButton.disabled = true; // Disable button after clearing
      }
    };

// Function to load token/user info from storage on startup
    async function loadAuthStateFromStorage() {
         console.log("Attempting to load auth state from storage...");
         try {
             // Use Figma Client Storage API - more persistent than localStorage in plugins


             if (storedToken && storedUserInfo) {
                 console.log("Found stored token and user info.");
                 // Optional: Verify token with backend immediately? Or assume it's valid until first API call fails?
                 // Let's assume valid for now to speed up startup. API calls will handle expiry.
                 userAuthToken = storedToken;
                 userInfo = storedUserInfo;
                 // isLoggedIn will be set by updateLoginUI
             } else {
                  console.log("No valid auth state found in storage.");
                  userAuthToken = null;
                  userInfo = null;
             }
         } catch (error) {
              console.error("Error loading auth state from storage:", error);
              userAuthToken = null;
              userInfo = null;
         } finally {
             updateLoginUI(); // Update UI based on loaded state (or lack thereof)
         }
    }

    // Add event listener for the verify button
    // verifyTokenButton.onclick = verifyToken;

    // Initial setup actions
    loadAuthStateFromStorage(); // Load stored auth state first
    // checkAuthStatus(); // Can remove this initial check, rely on stored token + verification


  </script>
</body>

</html>